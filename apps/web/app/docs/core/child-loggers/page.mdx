export const metadata = {
  title: 'Child Loggers',
  description: 'Create namespaced child loggers in Vestig for different application modules. Inherit configuration and add context.',
}

# Child Loggers

Create namespaced loggers for different parts of your application.

## Overview

Child loggers help you:

- **Organize logs** — Group logs by component or feature
- **Filter logs** — Find logs from specific parts of your app
- **Inherit configuration** — Share settings with parent logger

## Creating Child Loggers

```typescript
import { createLogger } from 'vestig'

const logger = createLogger({
  level: 'info',
  context: { service: 'api' }
})

// Create child loggers
const dbLogger = logger.child('database')
const authLogger = logger.child('auth')
const cacheLogger = logger.child('cache')

dbLogger.info('Query executed')
// → namespace: "database"

authLogger.info('User logged in')
// → namespace: "auth"
```

## Namespace Hierarchy

Child loggers can be nested to create hierarchies:

```typescript
const appLogger = logger.child('app')
const userService = appLogger.child('user-service')
const userRepo = userService.child('repository')

userRepo.info('User created')
// → namespace: "app:user-service:repository"
```

## Configuration Merge Semantics

Understanding how child logger configuration works is important for predictable behavior.

### Merge Behavior

Child loggers merge configuration with their parent using object spread:

```typescript
// Simplified internal implementation:
const childConfig = {
  ...parentConfig,    // Start with parent config
  ...childOptions,    // Override with child options
  namespace: fullNamespace,
  context: { ...parentConfig.context, ...childOptions?.context }
}
```

### Config Properties

| Property | Inheritance Behavior |
|----------|---------------------|
| `level` | Child overrides parent if specified |
| `enabled` | Child overrides parent if specified |
| `structured` | Child overrides parent if specified |
| `sanitize` | Child overrides parent if specified |
| `context` | Merged (parent + child, child wins conflicts) |
| `namespace` | Concatenated with `:` separator |
| `transports` | **Not inherited** - use same instance |

### Override Level

```typescript
// Parent with info level
const logger = createLogger({ level: 'info' })

// Child with debug level (for detailed debugging)
const debugLogger = logger.child('debug', {
  level: 'debug'
})

debugLogger.debug('This is visible')
logger.debug('This is not visible')
```

### Context Merging

Context is deeply merged, with child values taking precedence:

```typescript
const logger = createLogger({
  context: { service: 'api', version: '1.0', env: 'prod' }
})

const v2Logger = logger.child('v2', {
  context: { version: '2.0' }  // Only override version
})

v2Logger.info('Request')
// → context: { service: 'api', version: '2.0', env: 'prod' }
//            ↑ from parent    ↑ from child    ↑ from parent
```

### Transports Are Shared

Child loggers share the same transport instances as their parent:

```typescript
const logger = createLogger()
logger.addTransport(new HTTPTransport({ url: '...' }))

const child = logger.child('module')

// Both use the same HTTPTransport instance
logger.info('Parent log')  // → sent via HTTPTransport
child.info('Child log')    // → sent via same HTTPTransport
```

## Caching Behavior

### With No Config (Cached)

Child loggers without config options are cached via `WeakRef`:

```typescript
const logger = createLogger()

const child1 = logger.child('api')
const child2 = logger.child('api')

child1 === child2  // true (same instance)
```

This prevents memory bloat when creating child loggers repeatedly (e.g., per-request).

### With Config (Not Cached)

Child loggers with config options are never cached:

```typescript
const logger = createLogger()

const child1 = logger.child('api', { level: 'debug' })
const child2 = logger.child('api', { level: 'debug' })

child1 === child2  // false (different instances)
```

### Memory Management

Cached children use `WeakRef`, allowing garbage collection when no references remain:

```typescript
function processRequest(id: string) {
  const requestLogger = logger.child(id)  // Cached by namespace
  requestLogger.info('Processing')
  // When function exits and no references remain, GC can collect
}

// Safe to call millions of times - old children are GC'd
for (let i = 0; i < 1000000; i++) {
  processRequest(`req-${i}`)
}
```

**Tip:** For request-scoped logging with unique IDs, use context instead of namespace:

```typescript
// ✅ Better: Single cached child, unique context per request
function processRequest(id: string) {
  const requestLogger = logger.child('request', { context: { requestId: id } })
  requestLogger.info('Processing')
}
```

## Use Cases

### By Feature

```typescript
const logger = createLogger()

const authLogger = logger.child('auth')
const paymentLogger = logger.child('payment')
const notificationLogger = logger.child('notification')
```

### By Layer

```typescript
const logger = createLogger()

const controllerLogger = logger.child('controller')
const serviceLogger = logger.child('service')
const repositoryLogger = logger.child('repository')
```

### By Component (React)

```typescript
// In a Server Component
import { getLogger } from '@vestig/next'

export async function UserProfile({ userId }) {
  const log = await getLogger('components:user-profile')

  log.debug('Rendering user profile', { userId })

  // ...
}
```

## Pattern: Service Logger

Common pattern for creating a logger per service:

```typescript
// lib/logger.ts
import { createLogger } from 'vestig'

const rootLogger = createLogger({
  level: process.env.LOG_LEVEL ?? 'info',
  context: {
    service: process.env.SERVICE_NAME,
    version: process.env.VERSION
  }
})

export function getServiceLogger(namespace: string) {
  return rootLogger.child(namespace)
}
```

```typescript
// services/user.ts
import { getServiceLogger } from '@/lib/logger'

const log = getServiceLogger('user-service')

export async function createUser(data: UserInput) {
  log.info('Creating user', { email: data.email })
  // ...
}
```

## Filtering by Namespace

Use namespace patterns in your log aggregation:

```bash
# Find all database logs
grep '"namespace":"database' logs.json

# Find all auth-related logs
grep '"namespace":"auth' logs.json
```

Or configure transports to filter:

```typescript
new HTTPTransport({
  endpoint: '...',
  filter: (entry) => entry.namespace?.startsWith('api:')
})
```

## Namespace in Sampling

Use namespace sampling for fine-grained control:

```typescript
import { createNamespaceSampler, createLogger } from 'vestig'

const sampler = createNamespaceSampler({
  defaultRate: 0.1,
  rates: {
    'api:*': 0.5,      // 50% of API logs
    'db:*': 0.25,      // 25% of DB logs
    'auth:*': 1.0      // All auth logs
  }
})

const logger = createLogger({
  sampling: { sampler }
})
```
